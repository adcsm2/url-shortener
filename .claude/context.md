# URL Shortener - Contexto del Proyecto

## ğŸ¯ PropÃ³sito
Construir un acortador de URLs (como bit.ly) para aprender sobre:
- Servidores HTTP con Express
- Bases de datos relacionales (PostgreSQL)
- GeneraciÃ³n de IDs Ãºnicos y cortos
- Redirecciones HTTP
- Routing y middleware

**Parte de**: Portfolio de proyectos para demostrar competencias tÃ©cnicas a recruiters.

## ğŸ› ï¸ Stack tÃ©cnico

### Core
- Node.js v20
- Express (servidor HTTP)
- TypeScript (strict mode obligatorio)
- PostgreSQL + TypeORM (ORM para DB)

### Testing
- Jest + Supertest (tests de API)
- Cobertura mÃ­nima: 80%

### Utilities
- nanoid (generaciÃ³n de IDs cortos)
- dotenv (variables de entorno)

### Infraestructura
- Docker Compose (PostgreSQL local)

## ğŸ“ Estructura del proyecto
````
url-shortener/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts              # Entry point, Express setup
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â””â”€â”€ Url.ts           # TypeORM entity
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ shorten.ts       # POST /shorten
â”‚   â”‚   â””â”€â”€ redirect.ts      # GET /:shortCode
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ urlService.ts    # LÃ³gica de negocio
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ idGenerator.ts   # GeneraciÃ³n de IDs Ãºnicos
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ shorten.test.ts
â”‚   â”‚   â””â”€â”€ redirect.test.ts
â”‚   â””â”€â”€ services/
â”‚       â””â”€â”€ urlService.test.ts
â”œâ”€â”€ docs/dev/
â”‚   â”œâ”€â”€ architecture/
â”‚   â”‚   â”œâ”€â”€ 001-id-generation.md  # Por quÃ© nanoid
â”‚   â”‚   â””â”€â”€ 002-database-choice.md # Por quÃ© PostgreSQL
â”‚   â””â”€â”€ learnings/
â”œâ”€â”€ docker-compose.yml        # PostgreSQL container
â”œâ”€â”€ .env.example
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
````

## ğŸš€ Endpoints a implementar

### 1. Shorten URL (POST /api/shorten)
````bash
POST /api/shorten
Content-Type: application/json

{
  "url": "https://example.com/very/long/url"
}

# Response:
{
  "shortUrl": "http://localhost:3000/abc123",
  "shortCode": "abc123",
  "originalUrl": "https://example.com/very/long/url"
}
````

### 2. Redirect (GET /:shortCode)
````bash
GET /abc123

# Response:
HTTP 302 Found
Location: https://example.com/very/long/url
````

### 3. Stats (GET /api/stats/:shortCode)
````bash
GET /api/stats/abc123

# Response:
{
  "shortCode": "abc123",
  "originalUrl": "https://example.com/very/long/url",
  "clicks": 42,
  "createdAt": "2025-02-11T10:00:00Z"
}
````

## ğŸ’¾ Modelo de datos

### Entity: Url
````typescript
@Entity()
export class Url {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true, length: 10 })
  shortCode: string;

  @Column('text')
  originalUrl: string;

  @Column({ default: 0 })
  clicks: number;

  @CreateDateColumn()
  createdAt: Date;
}
````

## âœ… Validaciones requeridas

### POST /api/shorten
- âœ… URL vÃ¡lida (usar librerÃ­a `validator` o regex)
- âœ… URL no vacÃ­a
- âœ… Protocolo HTTP/HTTPS requerido
- âœ… Longitud URL < 2048 caracteres

### GET /:shortCode
- âœ… shortCode existe en DB â†’ redirect
- âœ… shortCode NO existe â†’ 404 Not Found

### GeneraciÃ³n de IDs
- âœ… IDs Ãºnicos de 7 caracteres (nanoid)
- âœ… Manejar colisiones (muy improbable pero posible)
- âœ… Solo caracteres URL-safe (a-z, A-Z, 0-9, -, _)

## ğŸ§ª Estrategia de testing

### Tests de integraciÃ³n (con Supertest)
````typescript
describe('POST /api/shorten', () => {
  it('should shorten valid URL');
  it('should reject invalid URL');
  it('should reject URL without protocol');
  it('should return same shortCode for duplicate URL');
});

describe('GET /:shortCode', () => {
  it('should redirect to original URL');
  it('should increment click counter');
  it('should return 404 for non-existent code');
});

describe('GET /api/stats/:shortCode', () => {
  it('should return stats for existing code');
  it('should return 404 for non-existent code');
});
````

### Tests unitarios
````typescript
describe('urlService.shortenUrl', () => {
  it('should generate unique short code');
  it('should save URL to database');
  it('should handle duplicate URLs');
});

describe('idGenerator.generate', () => {
  it('should generate 7-character code');
  it('should generate unique codes');
  it('should only use URL-safe characters');
});
````

## ğŸ”§ Convenciones del proyecto

### TypeScript
- Strict mode habilitado
- No `any` permitido
- Interfaces explÃ­citas

### Express
- Router modular (routes/)
- Middleware para validaciones
- Error handling centralizado

### Base de datos
- TypeORM para migrations
- Entities en entities/
- Nunca raw SQL en routes

### Git
- Conventional Commits
- Ejemplos:
  - `feat: add shorten endpoint`
  - `feat: add redirect functionality`
  - `test: add integration tests for shorten`
  - `docs: document ID generation strategy`

### CÃ³digo generado por IA
````typescript
// Generated by Claude Code
// Purpose: [breve descripciÃ³n]
````

## ğŸ” Decisiones arquitectÃ³nicas a documentar

### DecisiÃ³n 001: Algoritmo de generaciÃ³n de IDs
**Problema:** Â¿CÃ³mo generar IDs cortos, Ãºnicos y URL-safe?

**Opciones:**
1. **nanoid** - GeneraciÃ³n aleatoria criptogrÃ¡ficamente segura
2. **Hash (MD5/SHA)** - Hashear URL completa y truncar
3. **Auto-increment + Base62** - ID numÃ©rico convertido a base62

**Documentar:**
- Por quÃ© nanoid (7 chars = 128+ millones de URLs antes de colisiÃ³n)
- Trade-off: IDs aleatorios vs secuenciales
- Longitud elegida (7 caracteres)

### DecisiÃ³n 002: PostgreSQL vs otros
**Problema:** Â¿QuÃ© base de datos usar?

**Opciones:**
1. **PostgreSQL** - Relacional, ACID, robusto
2. **MongoDB** - NoSQL, flexible
3. **Redis** - In-memory, rÃ¡pido

**Documentar:**
- Por quÃ© PostgreSQL (relaciones futuras, ACID, Ã­ndices Ãºnicos)
- Trade-off: Setup mÃ¡s complejo vs garantÃ­as de consistencia

## ğŸ“š Recursos de referencia

### DocumentaciÃ³n
- Express: https://expressjs.com/
- TypeORM: https://typeorm.io/
- nanoid: https://github.com/ai/nanoid
- Supertest: https://github.com/visionmedia/supertest

### Templates
- DecisiÃ³n arquitectÃ³nica: `.claude/templates/architecture-decision.md`

## ğŸ“ Objetivos de aprendizaje

Este proyecto demuestra a recruiters:

1. **Servidor HTTP**: Express setup, routing, middleware
2. **Base de datos relacional**: PostgreSQL + TypeORM, migrations, entities
3. **GeneraciÃ³n de IDs Ãºnicos**: Algoritmos, colisiones, probabilidades
4. **Redirecciones HTTP**: Status codes 302, Location headers
5. **Testing de APIs**: Supertest, tests de integraciÃ³n
6. **Docker Compose**: Levantar dependencias localmente
7. **Variables de entorno**: .env, configuraciÃ³n por ambiente

## ğŸªŸ Comandos Ãºtiles
````bash
# Setup
npm install
docker-compose up -d  # Levantar PostgreSQL

# Desarrollo
npm run dev           # Servidor con hot reload
npm run migration:run # Correr migrations
npm run migration:generate -- -n MigrationName

# Testing
npm test
npm run test:watch
npm run test:coverage

# Build
npm run build
npm start

# Docker
docker-compose up -d    # Levantar DB
docker-compose down     # Detener DB
docker-compose logs     # Ver logs
````

## âš ï¸ Edge cases importantes

- URL ya acortada anteriormente â†’ retornar mismo shortCode
- shortCode colisiÃ³n (improbable) â†’ regenerar
- URL invÃ¡lida â†’ 400 Bad Request con mensaje claro
- shortCode no existe â†’ 404 Not Found
- DB down â†’ 503 Service Unavailable
- URL muy larga (>2048) â†’ rechazar

## ğŸ” Seguridad

- **Rate limiting**: Limitar requests por IP (express-rate-limit)
- **ValidaciÃ³n de URLs**: No permitir `javascript:`, `file://`, etc.
- **SQL Injection**: TypeORM previene esto automÃ¡ticamente
- **No passwords**: Este proyecto no maneja autenticaciÃ³n (out of scope)