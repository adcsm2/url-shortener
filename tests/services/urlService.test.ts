// Generated by Claude Code
const mockRepository = {
  findOne: jest.fn(),
  create: jest.fn(),
  save: jest.fn(),
  increment: jest.fn()
};

jest.mock("../../src/data-source", () => ({
  AppDataSource: {
    getRepository: jest.fn(() => mockRepository)
  }
}));

jest.mock("../../src/utils/idGenerator", () => ({
  generateShortCode: jest.fn().mockReturnValue("abc1234")
}));

import { shortenUrl, getUrlByShortCode, incrementClicks } from "../../src/services/urlService";

describe("urlService", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("shortenUrl", () => {
    it("should create new short URL", async () => {
      const originalUrl = "https://example.com";
      // First findOne for existing URL, second for collision check
      mockRepository.findOne
        .mockResolvedValueOnce(null)
        .mockResolvedValueOnce(null);
      mockRepository.create.mockReturnValue({
        shortCode: "abc1234",
        originalUrl,
        clicks: 0
      });
      mockRepository.save.mockResolvedValue({
        id: 1,
        shortCode: "abc1234",
        originalUrl,
        clicks: 0,
        createdAt: new Date()
      });

      const result = await shortenUrl(originalUrl);

      expect(result.originalUrl).toBe(originalUrl);
      expect(mockRepository.save).toHaveBeenCalled();
    });

    it("should retry on collision and succeed", async () => {
      const { generateShortCode } = require("../../src/utils/idGenerator");
      const originalUrl = "https://collision-test.com";

      // First call: no existing URL
      // Second call: collision found (shortCode exists)
      // Third call: no collision
      mockRepository.findOne
        .mockResolvedValueOnce(null)       // check existing URL
        .mockResolvedValueOnce({ id: 99 }) // collision on first code
        .mockResolvedValueOnce(null);      // no collision on second code

      (generateShortCode as jest.Mock)
        .mockReturnValueOnce("collide")
        .mockReturnValueOnce("unique1");

      mockRepository.create.mockReturnValue({
        shortCode: "unique1",
        originalUrl,
        clicks: 0
      });
      mockRepository.save.mockResolvedValue({
        id: 2,
        shortCode: "unique1",
        originalUrl,
        clicks: 0,
        createdAt: new Date()
      });

      const result = await shortenUrl(originalUrl);

      expect(result.shortCode).toBe("unique1");
      expect(mockRepository.save).toHaveBeenCalled();
    });

    it("should return existing URL if already shortened", async () => {
      const originalUrl = "https://example.com";
      const existing = {
        id: 1,
        shortCode: "abc1234",
        originalUrl,
        clicks: 5,
        createdAt: new Date()
      };
      mockRepository.findOne.mockResolvedValue(existing);

      const result = await shortenUrl(originalUrl);

      expect(result).toEqual(existing);
      expect(mockRepository.save).not.toHaveBeenCalled();
    });
  });

  describe("getUrlByShortCode", () => {
    it("should return URL entity for existing code", async () => {
      const urlEntity = {
        id: 1,
        shortCode: "abc1234",
        originalUrl: "https://example.com",
        clicks: 0,
        createdAt: new Date()
      };
      mockRepository.findOne.mockResolvedValue(urlEntity);

      const result = await getUrlByShortCode("abc1234");

      expect(result).toEqual(urlEntity);
    });

    it("should return null for non-existent code", async () => {
      mockRepository.findOne.mockResolvedValue(null);

      const result = await getUrlByShortCode("nonexist");

      expect(result).toBeNull();
    });
  });

  describe("incrementClicks", () => {
    it("should call increment on repository", async () => {
      mockRepository.increment.mockResolvedValue(undefined);

      await incrementClicks("abc1234");

      expect(mockRepository.increment).toHaveBeenCalledWith(
        { shortCode: "abc1234" },
        "clicks",
        1
      );
    });
  });
});
